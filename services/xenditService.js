/**
 * Xendit Payment Service
 * Handles QRIS, E-Wallet, and Virtual Account payments for Indonesian market
 */

const { Xendit } = require("xendit-node");
const QRCode = require("qrcode");
const fs = require("fs").promises;
const path = require("path");

class XenditService {
  constructor() {
    this.xendit = new Xendit({
      secretKey: process.env.XENDIT_SECRET_KEY,
    });

    // Rate conversion USD to IDR
    this.usdToIdrRate = parseFloat(process.env.USD_TO_IDR_RATE || "15800");

    // Payment QR code storage directory
    this.qrDir = path.join(__dirname, "payment_qris");
  }

  /**
   * Convert USD to IDR
   */
  convertToIDR(usdAmount) {
    return Math.ceil(usdAmount * this.usdToIdrRate);
  }

  /**
   * Create QRIS payment
   * @param {number} amountIDR - Amount in IDR
   * @param {string} referenceId - Unique order ID
   * @param {object} customerDetails - Customer information
   * @returns {Promise<{qrString: string, invoiceId: string, expiresAt: string}>}
   */
  async createQrisPayment(amountIDR, referenceId, customerDetails = {}) {
    try {
      const { PaymentRequest } = this.xendit;

      const paymentRequest = await PaymentRequest.createPaymentRequest({
        data: {
          amount: amountIDR,
          currency: "IDR",
          referenceId: referenceId,
          country: "ID",
          paymentMethod: {
            type: "QR_CODE",
            qrCode: {
              channelCode: "QRIS",
            },
            reusability: "ONE_TIME_USE",
          },
          metadata: {
            customerPhone: customerDetails.phone || "",
            customerName: customerDetails.name || "Customer",
          },
        },
      });

      // Generate QR code image
      // QR string is in paymentMethod.qrCode.channelProperties.qrString
      const qrString =
        paymentRequest.paymentMethod?.qrCode?.channelProperties?.qrString ||
        paymentRequest.qrString ||
        "";

      if (!qrString) {
        console.error("❌ QR code not found in response");
        throw new Error("QR code not generated by Xendit");
      }

      const qrCodePath = await this.generateQRImage(qrString, referenceId);

      return {
        qrString: qrString,
        qrCodePath: qrCodePath,
        invoiceId: paymentRequest.id,
        expiresAt: paymentRequest.metadata?.expiryDate || "",
        status: paymentRequest.status,
      };
    } catch (error) {
      console.error("❌ Xendit QRIS Error:", error.message);
      throw new Error(`Failed to create QRIS payment: ${error.message}`);
    }
  }

  /**
   * Create E-Wallet payment (OVO, DANA, GoPay, ShopeePay, LinkAja)
   * @param {number} amountIDR - Amount in IDR
   * @param {string} referenceId - Unique order ID
   * @param {string} ewalletType - 'OVO', 'DANA', 'SHOPEEPAY', 'LINKAJA'
   * @param {object} customerDetails - Customer information
   * @returns {Promise<{redirectUrl: string, invoiceId: string, checkoutUrl: string}>}
   */
  async createEwalletPayment(
    amountIDR,
    referenceId,
    ewalletType,
    customerDetails = {}
  ) {
    try {
      const { PaymentRequest } = this.xendit;

      const channelCode = ewalletType.toUpperCase();
      const successReturnUrl = process.env.WEBHOOK_URL
        ? `${process.env.WEBHOOK_URL}/payment-success?ref=${referenceId}`
        : `https://wa.me/${process.env.PAIRING_PHONE_NUMBER}`;

      // Build channel properties based on e-wallet type
      const channelProperties = {
        successReturnUrl: successReturnUrl,
        failureReturnUrl: successReturnUrl,
      };

      // OVO requires mobile number
      if (channelCode === "OVO") {
        // Extract phone number without country code and @c.us
        const phone = customerDetails.phone?.replace(/@c\.us$/, "") || "";
        // OVO format: without +62, just 08xxx
        const mobileNumber = phone.startsWith("62")
          ? "0" + phone.substring(2)
          : phone;
        channelProperties.mobileNumber = mobileNumber;
      }

      const paymentRequest = await PaymentRequest.createPaymentRequest({
        data: {
          amount: amountIDR,
          currency: "IDR",
          referenceId: referenceId,
          country: "ID",
          paymentMethod: {
            type: "EWALLET",
            ewallet: {
              channelCode: channelCode,
              channelProperties: channelProperties,
            },
            reusability: "ONE_TIME_USE",
          },
          metadata: {
            customerPhone: customerDetails.phone || "",
            customerName: customerDetails.name || "Customer",
          },
        },
      });

      // Get redirect URL from actions
      const redirectAction = paymentRequest.actions?.find(
        (action) => action.action === "REDIRECT_URL" || action.action === "AUTH"
      );

      return {
        redirectUrl: redirectAction?.url || paymentRequest.checkoutUrl || "",
        invoiceId: paymentRequest.id,
        checkoutUrl: paymentRequest.checkoutUrl || "",
        status: paymentRequest.status,
        ewalletType: channelCode,
      };
    } catch (error) {
      console.error(
        `❌ Xendit E-Wallet (${ewalletType}) Error:`,
        error.message
      );
      throw new Error(
        `Failed to create ${ewalletType} payment: ${error.message}`
      );
    }
  }

  /**
   * Create Virtual Account payment (Bank Transfer)
   * @param {number} amountIDR - Amount in IDR
   * @param {string} referenceId - Unique order ID
   * @param {string} bankCode - 'BCA', 'BNI', 'BRI', 'MANDIRI', 'PERMATA'
   * @param {object} customerDetails - Customer information
   * @returns {Promise<{vaNumber: string, bankCode: string, invoiceId: string, expiresAt: string}>}
   */
  async createVirtualAccount(
    amountIDR,
    referenceId,
    bankCode,
    customerDetails = {}
  ) {
    try {
      const { PaymentRequest } = this.xendit;

      const paymentRequest = await PaymentRequest.createPaymentRequest({
        data: {
          amount: amountIDR,
          currency: "IDR",
          referenceId: referenceId,
          country: "ID",
          paymentMethod: {
            type: "VIRTUAL_ACCOUNT",
            virtualAccount: {
              channelCode: bankCode.toUpperCase(),
              channelProperties: {
                customerName: customerDetails.name || "Customer",
              },
            },
            reusability: "ONE_TIME_USE",
            referenceId: `va-${referenceId}`,
          },
          metadata: {
            customerPhone: customerDetails.phone || "",
          },
        },
      });

      // Extract VA number from channel properties
      const vaNumber =
        paymentRequest.paymentMethod?.virtualAccount?.channelProperties
          ?.virtualAccountNumber ||
        paymentRequest.virtualAccountNumber ||
        "Pending";

      // Default expiry: 24 hours from now
      const expiresAt = new Date(
        Date.now() + 24 * 60 * 60 * 1000
      ).toISOString();

      return {
        vaNumber: vaNumber,
        bankCode: bankCode.toUpperCase(),
        bankName: this.getBankName(bankCode),
        invoiceId: paymentRequest.id,
        expiresAt: expiresAt,
        amount: amountIDR,
        status: paymentRequest.status,
      };
    } catch (error) {
      console.error(`❌ Xendit VA (${bankCode}) Error:`, error.message);
      throw new Error(`Failed to create Virtual Account: ${error.message}`);
    }
  }

  /**
   * Check payment status
   * @param {string} paymentId - Xendit payment request ID
   * @returns {Promise<{status: string, paidAt: string|null}>}
   */
  async checkPaymentStatus(paymentId) {
    try {
      const { PaymentRequest } = this.xendit;

      const payment = await PaymentRequest.getPaymentRequestByID({
        paymentRequestId: paymentId,
      });

      return {
        status: payment.status, // PENDING, SUCCEEDED, FAILED, EXPIRED
        paidAt: payment.updated || null,
        amount: payment.amount,
        paymentMethod: payment.paymentMethod?.type,
      };
    } catch (error) {
      console.error("❌ Xendit Status Check Error:", error.message);
      throw new Error(`Failed to check payment status: ${error.message}`);
    }
  }

  /**
   * Generate QR code image from string
   * @param {string} qrString - QR code data string
   * @param {string} referenceId - Order reference ID
   * @returns {Promise<string>} - Path to generated QR image
   */
  async generateQRImage(qrString, referenceId) {
    try {
      // Ensure directory exists
      await fs.mkdir(this.qrDir, { recursive: true });

      const filename = `qris_${referenceId}.png`;
      const filepath = path.join(this.qrDir, filename);

      // Generate QR code with high error correction
      await QRCode.toFile(filepath, qrString, {
        errorCorrectionLevel: "H",
        type: "png",
        width: 300,
        margin: 1,
      });

      console.log(`✅ QR Code generated: ${filename}`);
      return filepath;
    } catch (error) {
      console.error("❌ QR Code generation error:", error.message);
      throw error;
    }
  }

  /**
   * Get bank name from code
   */
  getBankName(bankCode) {
    const banks = {
      BCA: "Bank Central Asia",
      BNI: "Bank Negara Indonesia",
      BRI: "Bank Rakyat Indonesia",
      MANDIRI: "Bank Mandiri",
      PERMATA: "Bank Permata",
      CIMB: "Bank CIMB Niaga",
    };
    return banks[bankCode.toUpperCase()] || bankCode;
  }

  /**
   * Verify webhook signature (for security)
   * @param {string} webhookToken - X-CALLBACK-TOKEN from Xendit webhook header
   * @returns {boolean}
   */
  verifyWebhookToken(webhookToken) {
    const expectedToken = process.env.XENDIT_WEBHOOK_TOKEN;
    if (!expectedToken) {
      console.warn(
        "⚠️  XENDIT_WEBHOOK_TOKEN not configured, skipping verification"
      );
      return true; // Allow in development
    }
    return webhookToken === expectedToken;
  }
}

module.exports = new XenditService();
